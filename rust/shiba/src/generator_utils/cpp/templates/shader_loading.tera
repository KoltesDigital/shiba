{% if passes | length == 1 %}

	{
		shibaProgram = glCreateProgram();
		shibaCheckGlError();

		const char *vertexShaderSources[] = {
			{% if passes[0].vertex %}
				{% if shader_codes.before_stage_variables %}
					_shibaShaderBeforeStageVariablesCode,
				{% endif %}
				{% if shader_codes.vertex_specific %}
					_shibaShaderVertexSpecificCode,
				{% endif %}
				{% if shader_codes.after_stage_variables %}
					_shibaShaderAfterStageVariablesCode,
				{% endif %}
				_shibaShaderPassCodes[0],
			{% elif blender_api %}
				_shibaShaderNullVertexCode,
			{% endif %}
		};

		GLint vertexShader = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(vertexShader, sizeof(vertexShaderSources) / sizeof(vertexShaderSources[0]), vertexShaderSources, 0);
		shibaCheckGlError();
		glCompileShader(vertexShader);
		shibaCheckGlError();
		shibaCheckShaderInfoLog(vertexShader);
		glAttachShader(shibaProgram, vertexShader);
		shibaCheckGlError();

		{% if development %}
			_shibaVertexShaders[0] = vertexShader;
		{% endif %}

		{% if passes[0].fragment %}
			const char *fragmentShaderSources[] = {
				{% if shader_codes.before_stage_variables %}
					_shibaShaderBeforeStageVariablesCode,
				{% endif %}
				{% if shader_codes.fragment_specific %}
					_shibaShaderFragmentSpecificCode,
				{% endif %}
				{% if shader_codes.after_stage_variables %}
					_shibaShaderAfterStageVariablesCode,
				{% endif %}
				_shibaShaderPassCodes[1],
			};

			GLint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
			glShaderSource(fragmentShader, sizeof(fragmentShaderSources) / sizeof(fragmentShaderSources[0]), fragmentShaderSources, 0);
			shibaCheckGlError();
			glCompileShader(fragmentShader);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(fragmentShader);
			glAttachShader(shibaProgram, fragmentShader);
			shibaCheckGlError();

			{% if development %}
				_shibaFragmentShaders[0] = fragmentShader;
			{% endif %}
		{% else %}
			{% if development %}
				_shibaFragmentShaders[0] = 0;
			{% endif %}
		{% endif %}

		glLinkProgram(shibaProgram);
		shibaCheckGlError();

		shibaCheckProgramInfoLog(shibaProgram);

		{% for uniform_array in uniform_arrays %}
			shibaUniformLocations[0][{{ loop.index - 1 }}] = glGetUniformLocation(shibaProgram, "{% if uniform_array.minified_name %}{{ uniform_array.minified_name }}{% else %}{{ uniform_array.name }}{% endif %}");
		{% endfor %}

		{% if development %}
			shibaLog() << "Uniform locations in pass " << 0 << ":";
			{% for uniform_array in uniform_arrays %}
				shibaLog() << "{{ uniform_array.type_name }}: " << shibaUniformLocations[0][{{ loop.index - 1 }}];
			{% endfor %}
			shibaLog();
		{% endif %}
	}

{% else %}

	for (auto i = 0; i < {{ passes | length }}; ++i)
	{
		shibaPrograms[i] = glCreateProgram();
		shibaCheckGlError();

		if (_shibaShaderPassCodes[i * 2]
			{% if target == "blender_api" %}
				|| i == {{ passes | length - 1 }}
			{% endif %}
		)
		{
			const char *vertexShaderSources[] = {
				{% if shader_codes.before_stage_variables %}
					_shibaShaderBeforeStageVariablesCode,
				{% endif %}
				{% if shader_codes.vertex_specific %}
					_shibaShaderVertexSpecificCode,
				{% endif %}
				{% if shader_codes.after_stage_variables %}
					_shibaShaderAfterStageVariablesCode,
				{% endif %}
				_shibaShaderPassCodes[i * 2],
			};

			GLint vertexShader = glCreateShader(GL_VERTEX_SHADER);
			shibaCheckGlError();
			{% if target == "blender_api" %}
				if (i == {{ passes | length - 1 }})
				{
					glShaderSource(vertexShader, 1, &_shibaShaderNullVertexCode, 0);
				}
				else
				{
					glShaderSource(vertexShader, sizeof(vertexShaderSources) / sizeof(vertexShaderSources[0]), vertexShaderSources, 0);
				}
			{% else %}
				glShaderSource(vertexShader, sizeof(vertexShaderSources) / sizeof(vertexShaderSources[0]), vertexShaderSources, 0);
			{% endif %}
			shibaCheckGlError();
			glCompileShader(vertexShader);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(vertexShader);
			glAttachShader(shibaPrograms[i], vertexShader);
			shibaCheckGlError();

			{% if development %}
				_shibaVertexShaders[i] = vertexShader;
			{% endif %}
		}
		{% if development %}
			else
			{
				_shibaVertexShaders[i] = 0;
			}
		{% endif %}

		if (_shibaShaderPassCodes[i * 2 + 1])
		{
			const char *fragmentShaderSources[] = {
				{% if shader_codes.before_stage_variables %}
					_shibaShaderBeforeStageVariablesCode,
				{% endif %}
				{% if shader_codes.fragment_specific %}
					_shibaShaderFragmentSpecificCode,
				{% endif %}
				{% if shader_codes.after_stage_variables %}
					_shibaShaderAfterStageVariablesCode,
				{% endif %}
				_shibaShaderPassCodes[i * 2 + 1],
			};

			GLint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
			shibaCheckGlError();
			glShaderSource(fragmentShader, sizeof(fragmentShaderSources) / sizeof(fragmentShaderSources[0]), fragmentShaderSources, 0);
			shibaCheckGlError();
			glCompileShader(fragmentShader);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(fragmentShader);
			glAttachShader(shibaPrograms[i], fragmentShader);
			shibaCheckGlError();

			{% if development %}
				_shibaFragmentShaders[i] = fragmentShader;
			{% endif %}
		}
		{% if development %}
			else
			{
				_shibaFragmentShaders[i] = 0;
			}
		{% endif %}

		glLinkProgram(shibaPrograms[i]);
		shibaCheckGlError();

		shibaCheckProgramInfoLog(shibaPrograms[i]);

		{% for uniform_array in uniform_arrays %}
			shibaUniformLocations[i][{{ loop.index - 1 }}] = glGetUniformLocation(shibaPrograms[i], "{% if uniform_array.minified_name %}{{ uniform_array.minified_name }}{% else %}{{ uniform_array.name }}{% endif %}");
		{% endfor %}

		{% if development %}
			shibaLog() << "Uniform locations in pass " << i << ":";
			{% for uniform_array in uniform_arrays %}
				shibaLog() << "{{ uniform_array.type_name }}: " << shibaUniformLocations[i][{{ loop.index - 1 }}];
			{% endfor %}
			shibaLog();
		{% endif %}
	}

{% endif %}
