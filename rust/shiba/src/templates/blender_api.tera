#include <windows.h>

#define GLEW_STATIC

#include <cstdlib>
#include <GL/glew.h>
#include <GL/gl.h>
#include <iostream>
#include <map>
#include <thread>

{{ api }}

{% if custom.declaration %}
	{{ custom.declaration }}
{% endif %}

{{ shader_declarations }}

#define _SHIBA_EXPORT extern "C" __declspec(dllexport)

static void _shibaCommonRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	glViewport(0, 0, shibaResolutionWidth, shibaResolutionHeight);
	shibaCheckGlError();

	{{ render }}
}

static bool _shibaInitializeGlew()
{
	auto err = glewInit();
	if (GLEW_OK != err)
	{
		shibaError() << "Failed to initialize GLEW: " << glewGetErrorString(err);
		return false;
	}

	return true;
}

static void _shibaCommonInitialize(int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCreateScreenRect();

	{{ shader_loading }}

	{% if custom.initialization %}
		{{ custom.initialization }}
	{% endif %}
}

struct _ShibaContextDescriptor
{
	HWND window{ nullptr };
	HGLRC context{ nullptr };
};

static HANDLE _shibaContextDescriptorsByThreadIdMutex = nullptr;
static std::map<std::thread::id, std::unique_ptr<_ShibaContextDescriptor>> _shibaContextDescriptorsByThreadId;

SHIBA_VARIABLE bool _shibaIsInitialized = false;
SHIBA_VARIABLE _ShibaContextDescriptor *_shibaContextDescriptor;
SHIBA_VARIABLE GLuint _shibaFinalFramebufferId;
SHIBA_VARIABLE GLuint _shibaFinalFramebufferTextureId;

static void _shibaCommonUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
}

static bool _shibaCreateContext()
{
	PIXELFORMATDESCRIPTOR pfd =
	{
		sizeof(PIXELFORMATDESCRIPTOR),
		1,
		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL,
		PFD_TYPE_RGBA,
		32,
		0, 0, 0, 0, 0, 0,
		0,
		0,
		0,
		0, 0, 0, 0,
		24,
		8,
		0,
		PFD_MAIN_PLANE,
		0,
		0, 0, 0
	};

	_shibaContextDescriptor->window = CreateWindowA("static", NULL, WS_POPUP, 0, 0, 1, 1, NULL, NULL, NULL, 0);
	auto dc = GetDC(_shibaContextDescriptor->window);

	auto pixelFormat = ChoosePixelFormat(dc, &pfd);
	SetPixelFormat(dc, pixelFormat, &pfd);
	shibaCheckWindowsError();

	_shibaContextDescriptor->context = wglCreateContext(dc);
	shibaCheckWindowsError();

	if (_shibaContextDescriptor->context == nullptr)
	{
		return false;
	}

	wglMakeCurrent(dc, _shibaContextDescriptor->context);
	shibaCheckWindowsError();

	shibaLog() << "Created context " << _shibaContextDescriptor->context << ".";

	return true;
}

_SHIBA_EXPORT void _shibaUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCommonUpdate(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

_SHIBA_EXPORT void _shibaRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight, bool isPreview, void *buffer)
{
	if (!_shibaIsInitialized)
	{
		_shibaContextDescriptor = new _ShibaContextDescriptor{};

		{
			_ShibaMutexGuard guard{ _shibaContextDescriptorsByThreadIdMutex };
			_shibaContextDescriptorsByThreadId.insert(std::make_pair(std::this_thread::get_id(), std::unique_ptr<_ShibaContextDescriptor>{ _shibaContextDescriptor }));
		}

		if (!_shibaContextDescriptor->context && !_shibaCreateContext())
		{
			return;
		}

		if (!_shibaInitializeGlew())
		{
			return;
		}

		_shibaCommonInitialize(shibaResolutionWidth, shibaResolutionHeight);

		shibaCheckGlError();
		glGenTextures(1, &_shibaFinalFramebufferTextureId);
		shibaCheckGlError();
		glBindTexture(GL_TEXTURE_2D, _shibaFinalFramebufferTextureId);
		shibaCheckGlError();
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB32F, shibaResolutionWidth, shibaResolutionHeight, 0, GL_RGBA, GL_FLOAT, NULL);
		shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		shibaCheckGlError();
		//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		//shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		shibaCheckGlError();

		glGenFramebuffers(1, &_shibaFinalFramebufferId);
		shibaCheckGlError();

		glBindFramebuffer(GL_FRAMEBUFFER, _shibaFinalFramebufferId);
		shibaCheckGlError();
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _shibaFinalFramebufferTextureId, 0);
		shibaCheckGlError();
		auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
		shibaCheckGlError();
		if (status != GL_FRAMEBUFFER_COMPLETE)
		{
			shibaError() << "Final framebuffer is incomplete!";
			return;
		}
		else
		{
			shibaLog() << "Final framebuffer is complete.";
		}

		shibaFinalFramebufferId = _shibaFinalFramebufferId;

		_shibaIsInitialized = true;
	}
	else
	{
		glBindFramebuffer(GL_FRAMEBUFFER, shibaFinalFramebufferId);
		shibaCheckGlError();
	}

	_shibaCommonRender(shibaTime, shibaResolutionWidth, shibaResolutionHeight);

	glReadBuffer(GL_COLOR_ATTACHMENT0);
	shibaCheckGlError();
	glReadPixels(0, 0, shibaResolutionWidth, shibaResolutionHeight, GL_RGBA, GL_FLOAT, buffer);
	shibaCheckGlError();
}

_SHIBA_EXPORT void _shibaViewportUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCommonUpdate(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

_SHIBA_EXPORT void _shibaViewportRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	if (!_shibaIsInitialized)
	{
		if (!_shibaInitializeGlew())
		{
			return;
		}

		glGetIntegerv(GL_FRAMEBUFFER_BINDING, &shibaFinalFramebufferId);
		shibaCheckGlError();

		_shibaCommonInitialize(shibaResolutionWidth, shibaResolutionHeight);

		_shibaIsInitialized = true;
	}

	// Viewport sets a different default clear color.
	glClearColor(0.f, 0.f, 0.f, 0.f);
	shibaCheckGlError();

	_shibaCommonRender(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

struct _ShibaShaderPasses
{
	const char *vertex;
	const char *fragment;
};

_SHIBA_EXPORT void _shibaReloadShaderPasses(int count, _ShibaShaderPasses *passes)
{
	if (count != {{ passes | length }})
	{
		return;
	}

	glUseProgram(0);
	shibaCheckGlError();

	for (int i = 0; i < {{ passes | length }}; ++i)
	{
		auto &pass = passes[i];

		if (pass.vertex != nullptr && i != {{ passes | length - 1 }})
		{
			glShaderSource(_shibaVertexShaders[i], 1, &pass.vertex, 0);
			shibaCheckGlError();
			glCompileShader(_shibaVertexShaders[i]);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(_shibaVertexShaders[i]);
		}

		if (pass.fragment != nullptr)
		{
			glShaderSource(_shibaFragmentShaders[i], 1, &pass.fragment, 0);
			shibaCheckGlError();
			glCompileShader(_shibaFragmentShaders[i]);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(_shibaFragmentShaders[i]);
		}

		auto program =
			{% if passes | length == 1 %}
				shibaProgram
			{% else %}
				shibaPrograms[i]
			{% endif %}
		;

		glLinkProgram(program);
		shibaCheckGlError();

		shibaCheckProgramInfoLog(program);

		{% for element in uniform_arrays %}
			shibaUniformLocations[i][{{ loop.index - 1 }}] = glGetUniformLocation(program, "{% if element.uniform_array.minified_name %}{{ element.uniform_array.minified_name }}{% else %}{{ element.uniform_array.name }}{% endif %}");
		{% endfor %}

		shibaLog() << "Uniform locations in pass " << i << ":";
		{% for element in uniform_arrays %}
			shibaLog() << "{{ element.type_name }}: " << shibaUniformLocations[i][{{ loop.index - 1 }}];
		{% endfor %}
		shibaLog();
	}
}

static void _shibaDeleteContext(const _ShibaContextDescriptor *descriptor)
{
	shibaLog() << "Deleting context " << descriptor->context << ".";

	wglDeleteContext(descriptor->context);
	shibaCheckWindowsError();

	DestroyWindow(descriptor->window);
	shibaCheckWindowsError();
}

static void _shibaProcessAttach()
{
	_shibaContextDescriptorsByThreadIdMutex = CreateMutex(NULL, FALSE, NULL);
	shibaCheckWindowsError();
}

static void _shibaProcessDetach()
{
	CloseHandle(_shibaContextDescriptorsByThreadIdMutex);
	shibaCheckWindowsError();

	for (auto &pair : _shibaContextDescriptorsByThreadId)
	{
		_shibaDeleteContext(pair.second.get());
	}
}

static void _shibaThreadDetach()
{
	_ShibaMutexGuard guard{ _shibaContextDescriptorsByThreadIdMutex };
	auto it = _shibaContextDescriptorsByThreadId.find(std::this_thread::get_id());
	if (it != _shibaContextDescriptorsByThreadId.end())
	{
		_shibaDeleteContext(it->second.get());
		_shibaContextDescriptorsByThreadId.erase(it);
	}
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
			shibaLog() << "Attaching DLL to process " << GetCurrentProcessId() << ".";
			_shibaProcessAttach();
			break;

		case DLL_PROCESS_DETACH:
			shibaLog() << "Detaching DLL from process " << GetCurrentProcessId() << ".";
			_shibaProcessDetach();
			break;

		case DLL_THREAD_ATTACH:
			shibaLog() << "Attaching DLL to thread " << std::this_thread::get_id() << ".";
			break;

		case DLL_THREAD_DETACH:
			shibaLog() << "Detaching DLL from thread " << std::this_thread::get_id() << ".";
			_shibaThreadDetach();
			break;
	}

	return TRUE;
}
