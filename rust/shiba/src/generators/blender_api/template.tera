#include <windows.h>

#define GLEW_STATIC

#include <cstdlib>
#include <GL/glew.h>
#include <GL/gl.h>

{{ api }}

{{ opengl_declarations }}

{{ shader_declarations }}

{% if project_codes.declarations %}
	{{ project_codes.declarations }}
{% endif %}

#define _SHIBA_EXPORT extern "C" __declspec(dllexport)

static void _shibaCommonUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
}

static void _shibaCommonInitialize(int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCreateScreenRect();

	{{ shader_loading }}

	_shibaObjectMatrices.reset(new std::map<std::string, ShibaMat4>{});

	{% if project_codes.initialization %}
		{{ project_codes.initialization }}
	{% endif %}
}

static void _shibaCommonRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	glViewport(0, 0, shibaResolutionWidth, shibaResolutionHeight);
	shibaCheckGlError();

	{{ render }}
}

_SHIBA_EXPORT void _shibaUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCommonUpdate(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

_SHIBA_EXPORT void _shibaEnsureIsInitialized(int32_t shibaResolutionWidth, int32_t shibaResolutionHeight, bool isPreview, void *buffer)
{
	_shibaStandaloneContext.use();

	if (!_shibaIsInitialized)
	{
		{{ opengl_loading }}

		_shibaCommonInitialize(shibaResolutionWidth, shibaResolutionHeight);

		shibaCheckGlError();
		glGenTextures(1, &_shibaFinalFramebufferTextureId);
		shibaCheckGlError();
		glBindTexture(GL_TEXTURE_2D, _shibaFinalFramebufferTextureId);
		shibaCheckGlError();
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB32F, shibaResolutionWidth, shibaResolutionHeight, 0, GL_RGBA, GL_FLOAT, NULL);
		shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		shibaCheckGlError();
		//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		//shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		shibaCheckGlError();
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		shibaCheckGlError();

		glGenFramebuffers(1, &_shibaFinalFramebufferId);
		shibaCheckGlError();

		glBindFramebuffer(GL_FRAMEBUFFER, _shibaFinalFramebufferId);
		shibaCheckGlError();
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _shibaFinalFramebufferTextureId, 0);
		shibaCheckGlError();
		auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
		shibaCheckGlError();
		if (status != GL_FRAMEBUFFER_COMPLETE)
		{
			shibaError() << "Final framebuffer is incomplete!";
			return;
		}
		else
		{
			shibaLog() << "Final framebuffer is complete.";
		}

		shibaFinalFramebufferId = _shibaFinalFramebufferId;

		shibaIsViewport = false;
		_shibaIsInitialized = true;
	}
	else
	{
		glBindFramebuffer(GL_FRAMEBUFFER, shibaFinalFramebufferId);
		shibaCheckGlError();
	}
}

_SHIBA_EXPORT void _shibaRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight, bool isPreview, void *buffer)
{
	_shibaCommonRender(shibaTime, shibaResolutionWidth, shibaResolutionHeight);

	glReadBuffer(GL_COLOR_ATTACHMENT0);
	shibaCheckGlError();
	glReadPixels(0, 0, shibaResolutionWidth, shibaResolutionHeight, GL_RGBA, GL_FLOAT, buffer);
	shibaCheckGlError();
}

_SHIBA_EXPORT void _shibaViewportUpdate(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	_shibaCommonUpdate(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

_SHIBA_EXPORT void _shibaViewportEnsureIsInitialized(int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	if (!_shibaIsInitialized)
	{
		{{ opengl_loading }}

		glGetIntegerv(GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint*>(&shibaFinalFramebufferId));
		shibaCheckGlError();

		_shibaCommonInitialize(shibaResolutionWidth, shibaResolutionHeight);

		glBindFramebuffer(GL_FRAMEBUFFER, shibaFinalFramebufferId);
		shibaCheckGlError();

		shibaIsViewport = true;
		_shibaIsInitialized = true;
	}
	else
	{
		glGetIntegerv(GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint*>(&shibaFinalFramebufferId));
		shibaCheckGlError();
	}
}

_SHIBA_EXPORT void _shibaViewportRender(float shibaTime, int32_t shibaResolutionWidth, int32_t shibaResolutionHeight)
{
	// Viewport sets a different default clear color.
	glClearColor(0.f, 0.f, 0.f, 0.f);
	shibaCheckGlError();

	_shibaCommonRender(shibaTime, shibaResolutionWidth, shibaResolutionHeight);
}

_SHIBA_EXPORT void _shibaUpdateObject(const char *name, ShibaMat4 worldMatrix)
{
	shibaObjectMatrices[name] = worldMatrix;
}

struct _ShibaShaderPasses
{
	const char *vertex;
	const char *fragment;
};

_SHIBA_EXPORT void _shibaUpdateShaderPasses(int count, _ShibaShaderPasses *passes)
{
	if (count != {{ passes | length }})
	{
		return;
	}

	glUseProgram(0);
	shibaCheckGlError();

	for (int i = 0; i < {{ passes | length }}; ++i)
	{
		auto &pass = passes[i];

		if (pass.vertex != nullptr && i != {{ passes | length - 1 }})
		{
			glShaderSource(_shibaVertexShaders[i], 1, &pass.vertex, 0);
			shibaCheckGlError();
			glCompileShader(_shibaVertexShaders[i]);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(_shibaVertexShaders[i]);
		}

		if (pass.fragment != nullptr)
		{
			glShaderSource(_shibaFragmentShaders[i], 1, &pass.fragment, 0);
			shibaCheckGlError();
			glCompileShader(_shibaFragmentShaders[i]);
			shibaCheckGlError();
			shibaCheckShaderInfoLog(_shibaFragmentShaders[i]);
		}

		auto program =
			{% if passes | length == 1 %}
				shibaProgram
			{% else %}
				shibaPrograms[i]
			{% endif %}
		;

		glLinkProgram(program);
		shibaCheckGlError();

		shibaCheckProgramInfoLog(program);

		{% for uniform_array in uniform_arrays %}
			shibaUniformLocations[i][{{ loop.index - 1 }}] = glGetUniformLocation(program, "{% if uniform_array.minified_name %}{{ uniform_array.minified_name }}{% else %}{{ uniform_array.name }}{% endif %}");
			shibaCheckGlError();
		{% endfor %}

		shibaLog() << "Uniform locations in pass " << i << ":";
		{% for uniform_array in uniform_arrays %}
			shibaLog() << "{{ uniform_array.type_name }}: " << shibaUniformLocations[i][{{ loop.index - 1 }}];
		{% endfor %}
		shibaLog();
	}
}

_SHIBA_EXPORT void _shibaSetOverrideMatrices(
	ShibaMat4 viewMatrix, ShibaMat4 invViewMatrix,
	ShibaMat4 projectionMatrix, ShibaMat4 invProjectionMatrix
)
{
	shibaOverrideMatricesSet = true;
	shibaOverrideViewMatrix = viewMatrix;
	shibaOverrideInvViewMatrix = invViewMatrix;
	shibaOverrideProjectionMatrix = projectionMatrix;
	shibaOverrideInvProjectionMatrix = invProjectionMatrix;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
	return TRUE;
}
